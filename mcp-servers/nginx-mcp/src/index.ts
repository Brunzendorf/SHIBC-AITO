/**
 * nginx MCP Server
 *
 * Manages nginx virtual hosts and reverse proxy configurations.
 * Designed for subdomain routing and SSL setup.
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import { z } from 'zod';
import { execSync } from 'child_process';
import { readFileSync, writeFileSync, readdirSync, existsSync, unlinkSync } from 'fs';
import { join } from 'path';

// ============================================
// CONFIGURATION
// ============================================

const NGINX_SITES_AVAILABLE = process.env.NGINX_SITES_AVAILABLE || '/etc/nginx/sites-available';
const NGINX_SITES_ENABLED = process.env.NGINX_SITES_ENABLED || '/etc/nginx/sites-enabled';
const ALLOWED_DOMAINS = (process.env.ALLOWED_DOMAINS || 'shibaclassic.io').split(',');

// ============================================
// LOGGING
// ============================================

function log(level: 'info' | 'error' | 'debug', message: string, data?: Record<string, unknown>) {
  const entry = {
    ts: new Date().toISOString(),
    level,
    component: 'nginx-mcp',
    msg: message,
    ...data,
  };
  console.error(JSON.stringify(entry));
}

// ============================================
// SECURITY
// ============================================

function validateDomain(domain: string): void {
  const isAllowed = ALLOWED_DOMAINS.some(allowed =>
    domain === allowed || domain.endsWith(`.${allowed}`)
  );
  if (!isAllowed) {
    throw new Error(`Domain not allowed: ${domain}. Allowed: ${ALLOWED_DOMAINS.join(', ')}`);
  }
}

function sanitizeName(name: string): string {
  return name.replace(/[^a-zA-Z0-9._-]/g, '');
}

// ============================================
// NGINX OPERATIONS
// ============================================

function listSites(): Array<{ name: string; enabled: boolean }> {
  const available = existsSync(NGINX_SITES_AVAILABLE)
    ? readdirSync(NGINX_SITES_AVAILABLE).filter(f => !f.startsWith('.'))
    : [];

  const enabled = existsSync(NGINX_SITES_ENABLED)
    ? readdirSync(NGINX_SITES_ENABLED).filter(f => !f.startsWith('.'))
    : [];

  return available.map(name => ({
    name,
    enabled: enabled.includes(name),
  }));
}

function getSiteConfig(name: string): string {
  const safeName = sanitizeName(name);
  const path = join(NGINX_SITES_AVAILABLE, safeName);
  if (!existsSync(path)) {
    throw new Error(`Site not found: ${name}`);
  }
  return readFileSync(path, 'utf-8');
}

function generateReverseProxyConfig(options: {
  serverName: string;
  proxyPass: string;
  ssl?: boolean;
  sslCertificate?: string;
  sslCertificateKey?: string;
  extraConfig?: string;
}): string {
  const { serverName, proxyPass, ssl, sslCertificate, sslCertificateKey, extraConfig } = options;

  let config = `# Generated by AITO nginx-mcp
# Server: ${serverName}
# Created: ${new Date().toISOString()}

server {
    listen 80;
    server_name ${serverName};
`;

  if (ssl) {
    config += `
    # Redirect HTTP to HTTPS
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name ${serverName};

    ssl_certificate ${sslCertificate || `/etc/letsencrypt/live/${serverName}/fullchain.pem`};
    ssl_certificate_key ${sslCertificateKey || `/etc/letsencrypt/live/${serverName}/privkey.pem`};
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
    ssl_prefer_server_ciphers off;
`;
  }

  config += `
    location / {
        proxy_pass ${proxyPass};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
`;

  if (extraConfig) {
    config += `\n    ${extraConfig.replace(/\n/g, '\n    ')}\n`;
  }

  config += `}
`;

  return config;
}

function generateStaticSiteConfig(options: {
  serverName: string;
  root: string;
  ssl?: boolean;
  sslCertificate?: string;
  sslCertificateKey?: string;
}): string {
  const { serverName, root, ssl, sslCertificate, sslCertificateKey } = options;

  let config = `# Generated by AITO nginx-mcp
# Server: ${serverName}
# Created: ${new Date().toISOString()}

server {
    listen 80;
    server_name ${serverName};
`;

  if (ssl) {
    config += `
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name ${serverName};

    ssl_certificate ${sslCertificate || `/etc/letsencrypt/live/${serverName}/fullchain.pem`};
    ssl_certificate_key ${sslCertificateKey || `/etc/letsencrypt/live/${serverName}/privkey.pem`};
`;
  }

  config += `
    root ${root};
    index index.html index.htm;

    location / {
        try_files $uri $uri/ /index.html;
    }

    location ~* \\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}
`;

  return config;
}

function writeSiteConfig(name: string, config: string): void {
  const safeName = sanitizeName(name);
  const path = join(NGINX_SITES_AVAILABLE, safeName);
  writeFileSync(path, config, 'utf-8');
  log('info', 'Site config written', { name: safeName, path });
}

function enableSite(name: string): void {
  const safeName = sanitizeName(name);
  const source = join(NGINX_SITES_AVAILABLE, safeName);
  const target = join(NGINX_SITES_ENABLED, safeName);

  if (!existsSync(source)) {
    throw new Error(`Site not found: ${name}`);
  }

  if (!existsSync(target)) {
    execSync(`ln -s "${source}" "${target}"`);
    log('info', 'Site enabled', { name: safeName });
  }
}

function disableSite(name: string): void {
  const safeName = sanitizeName(name);
  const target = join(NGINX_SITES_ENABLED, safeName);

  if (existsSync(target)) {
    unlinkSync(target);
    log('info', 'Site disabled', { name: safeName });
  }
}

function deleteSite(name: string): void {
  const safeName = sanitizeName(name);
  const available = join(NGINX_SITES_AVAILABLE, safeName);
  const enabled = join(NGINX_SITES_ENABLED, safeName);

  if (existsSync(enabled)) {
    unlinkSync(enabled);
  }
  if (existsSync(available)) {
    unlinkSync(available);
  }
  log('info', 'Site deleted', { name: safeName });
}

function testConfig(): { valid: boolean; output: string } {
  try {
    const output = execSync('nginx -t 2>&1', { encoding: 'utf-8' });
    return { valid: true, output };
  } catch (error) {
    const output = error instanceof Error ? (error as Error & { stdout?: string }).stdout || error.message : 'Unknown error';
    return { valid: false, output };
  }
}

function reloadNginx(): { success: boolean; output: string } {
  try {
    const output = execSync('nginx -s reload 2>&1', { encoding: 'utf-8' });
    return { success: true, output: output || 'Reload successful' };
  } catch (error) {
    const output = error instanceof Error ? error.message : 'Unknown error';
    return { success: false, output };
  }
}

// ============================================
// TOOL DEFINITIONS
// ============================================

const tools = [
  {
    name: 'nginx_list_sites',
    description: 'List all nginx sites (available and enabled)',
    inputSchema: { type: 'object' as const, properties: {}, required: [] },
  },
  {
    name: 'nginx_get_site',
    description: 'Get the configuration of a specific site',
    inputSchema: {
      type: 'object' as const,
      properties: {
        name: { type: 'string', description: 'Site name' },
      },
      required: ['name'],
    },
  },
  {
    name: 'nginx_create_reverse_proxy',
    description: 'Create a reverse proxy site configuration',
    inputSchema: {
      type: 'object' as const,
      properties: {
        name: { type: 'string', description: 'Site name (filename)' },
        server_name: { type: 'string', description: 'Domain name (e.g., api.shibaclassic.io)' },
        proxy_pass: { type: 'string', description: 'Backend URL (e.g., http://localhost:3000)' },
        ssl: { type: 'boolean', description: 'Enable SSL (default: false)' },
        enable: { type: 'boolean', description: 'Enable site after creation (default: true)' },
      },
      required: ['name', 'server_name', 'proxy_pass'],
    },
  },
  {
    name: 'nginx_create_static_site',
    description: 'Create a static file serving site configuration',
    inputSchema: {
      type: 'object' as const,
      properties: {
        name: { type: 'string', description: 'Site name (filename)' },
        server_name: { type: 'string', description: 'Domain name' },
        root: { type: 'string', description: 'Document root path' },
        ssl: { type: 'boolean', description: 'Enable SSL (default: false)' },
        enable: { type: 'boolean', description: 'Enable site after creation (default: true)' },
      },
      required: ['name', 'server_name', 'root'],
    },
  },
  {
    name: 'nginx_enable_site',
    description: 'Enable a site (create symlink to sites-enabled)',
    inputSchema: {
      type: 'object' as const,
      properties: {
        name: { type: 'string', description: 'Site name' },
      },
      required: ['name'],
    },
  },
  {
    name: 'nginx_disable_site',
    description: 'Disable a site (remove symlink from sites-enabled)',
    inputSchema: {
      type: 'object' as const,
      properties: {
        name: { type: 'string', description: 'Site name' },
      },
      required: ['name'],
    },
  },
  {
    name: 'nginx_delete_site',
    description: 'Delete a site configuration',
    inputSchema: {
      type: 'object' as const,
      properties: {
        name: { type: 'string', description: 'Site name' },
      },
      required: ['name'],
    },
  },
  {
    name: 'nginx_test_config',
    description: 'Test nginx configuration syntax',
    inputSchema: { type: 'object' as const, properties: {}, required: [] },
  },
  {
    name: 'nginx_reload',
    description: 'Reload nginx configuration (applies changes)',
    inputSchema: { type: 'object' as const, properties: {}, required: [] },
  },
];

// ============================================
// TOOL HANDLERS
// ============================================

async function handleToolCall(name: string, args: Record<string, unknown>) {
  switch (name) {
    case 'nginx_list_sites': {
      const sites = listSites();
      return { success: true, sites, count: sites.length };
    }

    case 'nginx_get_site': {
      const schema = z.object({ name: z.string() });
      const { name: siteName } = schema.parse(args);
      const config = getSiteConfig(siteName);
      return { success: true, name: siteName, config };
    }

    case 'nginx_create_reverse_proxy': {
      const schema = z.object({
        name: z.string(),
        server_name: z.string(),
        proxy_pass: z.string(),
        ssl: z.boolean().default(false),
        enable: z.boolean().default(true),
      });
      const params = schema.parse(args);

      validateDomain(params.server_name);

      const config = generateReverseProxyConfig({
        serverName: params.server_name,
        proxyPass: params.proxy_pass,
        ssl: params.ssl,
      });

      writeSiteConfig(params.name, config);

      if (params.enable) {
        enableSite(params.name);
      }

      return {
        success: true,
        name: params.name,
        server_name: params.server_name,
        enabled: params.enable,
        ssl: params.ssl,
      };
    }

    case 'nginx_create_static_site': {
      const schema = z.object({
        name: z.string(),
        server_name: z.string(),
        root: z.string(),
        ssl: z.boolean().default(false),
        enable: z.boolean().default(true),
      });
      const params = schema.parse(args);

      validateDomain(params.server_name);

      const config = generateStaticSiteConfig({
        serverName: params.server_name,
        root: params.root,
        ssl: params.ssl,
      });

      writeSiteConfig(params.name, config);

      if (params.enable) {
        enableSite(params.name);
      }

      return {
        success: true,
        name: params.name,
        server_name: params.server_name,
        root: params.root,
        enabled: params.enable,
      };
    }

    case 'nginx_enable_site': {
      const schema = z.object({ name: z.string() });
      const { name: siteName } = schema.parse(args);
      enableSite(siteName);
      return { success: true, name: siteName, enabled: true };
    }

    case 'nginx_disable_site': {
      const schema = z.object({ name: z.string() });
      const { name: siteName } = schema.parse(args);
      disableSite(siteName);
      return { success: true, name: siteName, enabled: false };
    }

    case 'nginx_delete_site': {
      const schema = z.object({ name: z.string() });
      const { name: siteName } = schema.parse(args);
      deleteSite(siteName);
      return { success: true, deleted: siteName };
    }

    case 'nginx_test_config': {
      const result = testConfig();
      return { success: true, valid: result.valid, output: result.output };
    }

    case 'nginx_reload': {
      const testResult = testConfig();
      if (!testResult.valid) {
        return {
          success: false,
          error: 'Configuration test failed',
          output: testResult.output,
        };
      }

      const reloadResult = reloadNginx();
      return {
        success: reloadResult.success,
        output: reloadResult.output,
      };
    }

    default:
      throw new Error(`Unknown tool: ${name}`);
  }
}

// ============================================
// SERVER SETUP
// ============================================

const server = new Server(
  { name: 'nginx-mcp', version: '1.0.0' },
  { capabilities: { tools: {} } }
);

server.setRequestHandler(ListToolsRequestSchema, async () => ({ tools }));

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  log('info', 'Tool called', { tool: name });

  try {
    const result = await handleToolCall(name, args as Record<string, unknown>);
    return {
      content: [{ type: 'text', text: JSON.stringify(result, null, 2) }],
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    log('error', 'Tool error', { tool: name, error: message });
    return {
      content: [{ type: 'text', text: JSON.stringify({ success: false, error: message }, null, 2) }],
      isError: true,
    };
  }
});

// ============================================
// MAIN
// ============================================

async function main() {
  log('info', 'nginx MCP Server starting', {
    sitesAvailable: NGINX_SITES_AVAILABLE,
    sitesEnabled: NGINX_SITES_ENABLED,
    allowedDomains: ALLOWED_DOMAINS,
  });

  const transport = new StdioServerTransport();
  await server.connect(transport);

  log('info', 'nginx MCP Server running');
}

main().catch((error) => {
  log('error', 'Fatal error', { error: error.message });
  process.exit(1);
});
