/**
 * Initiative Framework - Core Types
 * TASK-037: Plugin-fähiges Framework für dynamische Agent-Nutzung
 *
 * Design Principles:
 * - Generic Initiative<T> for custom payloads
 * - Provider-Pattern for agent-specific implementations
 * - Pluggable scoring strategies
 * - Composable context sources
 */

// =============================================================================
// BASE TYPES
// =============================================================================

/**
 * Agent types in the AITO system
 */
export type AgentType = 'ceo' | 'cmo' | 'cto' | 'cfo' | 'coo' | 'cco' | 'dao';

/**
 * Priority levels for initiatives
 */
export type Priority = 'critical' | 'high' | 'medium' | 'low';

/**
 * Status labels matching GitHub workflow
 */
export type IssueStatus = 'BACKLOG' | 'READY' | 'IN_PROGRESS' | 'REVIEW' | 'DONE' | 'BLOCKED';

/**
 * GitHub status label mapping
 */
export const STATUS_LABELS: Record<IssueStatus, string> = {
  BACKLOG: 'status:backlog',
  READY: 'status:ready',
  IN_PROGRESS: 'status:in-progress',
  REVIEW: 'status:review',
  DONE: 'status:done',
  BLOCKED: 'status:blocked',
};

// =============================================================================
// INITIATIVE TYPES
// =============================================================================

/**
 * Base initiative interface
 * Generic T allows custom payload extensions per provider
 */
export interface Initiative<T = unknown> {
  /** Clear, actionable title */
  title: string;
  /** What to do, why, expected outcome */
  description: string;
  /** Priority level */
  priority: Priority;
  /** Revenue impact score (0-10) */
  revenueImpact: number;
  /** Story points / effort estimate (0-10) */
  effort: number;
  /** Which agent should handle this */
  suggestedAssignee: AgentType;
  /** Categorization tags */
  tags: string[];
  /** Where this initiative came from */
  source: InitiativeSource;
  /** Optional custom payload for provider-specific data */
  payload?: T;
}

/**
 * Initiative source tracking
 */
export type InitiativeSource =
  | 'bootstrap'          // Pre-defined bootstrap initiatives
  | 'agent-proposed'     // AI-generated by agent
  | 'human-requested'    // Created by human
  | 'system-detected'    // Auto-detected by monitoring
  | 'cross-agent';       // Proposed by another agent

/**
 * Initiative proposal from AI
 */
export interface InitiativeProposal {
  title: string;
  description: string;
  rationale?: string;
  priority: string;
  revenueImpact: number;
  effort: number;
  communityImpact?: number;
  tags: string[];
}

/**
 * Result of creating an initiative
 */
export interface InitiativeResult<T = unknown> {
  initiative: Initiative<T>;
  issueUrl: string | null;
  issueNumber?: number;
}

/**
 * Result of running an initiative phase
 */
export interface InitiativePhaseResult<T = unknown> {
  created: boolean;
  initiative?: Initiative<T>;
  issueUrl?: string;
  needsAIGeneration?: boolean;
}

// =============================================================================
// FOCUS SETTINGS
// =============================================================================

/**
 * Dashboard-controlled focus settings
 * These influence scoring and prioritization
 */
export interface FocusSettings {
  /** How much to weight revenue impact (0-100) */
  revenueFocus: number;
  /** Community growth priority (0-100) */
  communityGrowth: number;
  /** Marketing vs Dev balance (0=dev, 100=marketing) */
  marketingVsDev: number;
  /** Risk tolerance (0=conservative, 100=aggressive) */
  riskTolerance: number;
  /** Time horizon (0=quick wins, 100=long term) */
  timeHorizon: number;
}

/**
 * Default focus settings
 */
export const DEFAULT_FOCUS: FocusSettings = {
  revenueFocus: 80,
  communityGrowth: 60,
  marketingVsDev: 50,
  riskTolerance: 40,
  timeHorizon: 30,
};

// =============================================================================
// SCORING STRATEGY
// =============================================================================

/**
 * Scoring context passed to strategies
 */
export interface ScoringContext {
  focus: FocusSettings;
  agentType: AgentType;
  existingInitiatives?: string[];
  marketConditions?: MarketConditions;
}

/**
 * Market conditions for context-aware scoring
 */
export interface MarketConditions {
  fearGreedIndex?: number;
  btcTrend?: 'up' | 'down' | 'stable';
  volume24h?: number;
  sentiment?: 'bullish' | 'bearish' | 'neutral';
}

/**
 * Scoring strategy interface
 * Implement this to create custom scoring algorithms
 */
export interface ScoringStrategy<T = unknown> {
  /** Unique identifier for this strategy */
  readonly name: string;

  /**
   * Calculate score for an initiative
   * Higher scores = higher priority
   */
  score(initiative: Initiative<T>, context: ScoringContext): number;

  /**
   * Optional: Adjust score based on similarity to existing initiatives
   * Returns penalty to subtract (0 = no penalty)
   */
  duplicatePenalty?(initiative: Initiative<T>, existing: Initiative<T>[]): number;
}

// =============================================================================
// CONTEXT SOURCES
// =============================================================================

/**
 * Context source interface
 * Implement this to add new data sources
 */
export interface ContextSource {
  /** Unique identifier */
  readonly name: string;

  /** Human-readable label for output */
  readonly label: string;

  /**
   * Fetch context data
   * Returns formatted string for prompt injection
   */
  fetch(agentType: AgentType): Promise<string>;

  /**
   * Optional: Check if source is available
   */
  isAvailable?(): Promise<boolean>;

  /**
   * Optional: Cache TTL in seconds (0 = no cache)
   */
  cacheTTL?: number;
}

/**
 * Built-in context source types
 */
export type BuiltInContextSource =
  | 'rag'
  | 'github'
  | 'team-status'
  | 'market-data'
  | 'telegram-metrics';

/**
 * Aggregated context from all sources
 */
export interface AggregatedContext {
  sources: Record<string, string>;
  focus: FocusSettings;
  agentFocus: AgentFocusConfig;
  existingTitles: string[];
  timestamp: Date;
}

// =============================================================================
// AGENT FOCUS CONFIGURATION
// =============================================================================

/**
 * Agent-specific focus areas
 */
export interface AgentFocusConfig {
  /** Key questions the agent should consider */
  keyQuestions: string[];
  /** Revenue angles for this role */
  revenueAngles: string[];
  /** Topics to scan in RAG */
  scanTopics: string[];
}

// =============================================================================
// PROVIDER INTERFACE
// =============================================================================

/**
 * Initiative Provider Interface
 *
 * Implement this to create agent-specific initiative handling.
 * Each agent type can register their own provider with custom:
 * - Context sources
 * - Scoring strategies
 * - Prompt templates
 * - Validation rules
 *
 * @example
 * ```typescript
 * const cmoProvider: InitiativeProvider = {
 *   agentType: 'cmo',
 *   getContextSources: () => ['rag', 'github', 'telegram-metrics'],
 *   getScoringStrategy: () => new MarketingFocusStrategy(),
 *   getPromptTemplate: () => CMO_INITIATIVE_PROMPT,
 *   validateInitiative: (init) => init.tags.some(t => t === 'marketing'),
 *   getBootstrapInitiatives: () => CMO_BOOTSTRAP,
 *   getFocusConfig: () => CMO_FOCUS,
 * };
 * ```
 */
export interface InitiativeProvider<T = unknown> {
  /** Agent type this provider handles */
  readonly agentType: AgentType;

  /**
   * Get context sources for this agent
   * Can include built-in sources and custom ones
   */
  getContextSources(): (BuiltInContextSource | ContextSource)[];

  /**
   * Get scoring strategy for this agent
   */
  getScoringStrategy(): ScoringStrategy<T>;

  /**
   * Get agent-specific focus configuration
   */
  getFocusConfig(): AgentFocusConfig;

  /**
   * Optional: Get prompt template for AI generation
   * Receives context and should return full prompt
   */
  getPromptTemplate?(context: AggregatedContext): string;

  /**
   * Optional: Validate an initiative before creation
   * Return true if valid, false to reject
   */
  validateInitiative?(initiative: Initiative<T>): boolean;

  /**
   * Optional: Transform initiative before creation
   * Can add agent-specific data to payload
   */
  transformInitiative?(initiative: Initiative<T>): Initiative<T>;

  /**
   * Optional: Get bootstrap initiatives for this agent
   * Used when AI generation is not available
   */
  getBootstrapInitiatives?(): Initiative<T>[];

  /**
   * Optional: Custom cooldown duration in seconds
   * Default: 3600 (1 hour)
   */
  getCooldownSeconds?(): number;

  /**
   * Optional: Hook called after initiative is created
   */
  onInitiativeCreated?(initiative: Initiative<T>, issueUrl: string | null): Promise<void>;
}

// =============================================================================
// REGISTRY
// =============================================================================

/**
 * Provider registration options
 */
export interface ProviderRegistrationOptions {
  /** Override existing provider for this agent type */
  override?: boolean;
}

/**
 * Initiative Registry Interface
 * Manages provider registration and lookup
 */
export interface InitiativeRegistry {
  /**
   * Register a provider for an agent type
   */
  register<T = unknown>(
    provider: InitiativeProvider<T>,
    options?: ProviderRegistrationOptions
  ): void;

  /**
   * Get provider for an agent type
   * Returns undefined if not registered
   */
  get<T = unknown>(agentType: AgentType): InitiativeProvider<T> | undefined;

  /**
   * Check if a provider is registered
   */
  has(agentType: AgentType): boolean;

  /**
   * Get all registered agent types
   */
  getRegisteredTypes(): AgentType[];

  /**
   * Unregister a provider
   */
  unregister(agentType: AgentType): boolean;
}

// =============================================================================
// GITHUB INTEGRATION
// =============================================================================

/**
 * GitHub issue summary for context
 */
export interface GitHubIssuesSummary {
  open: string[];
  recent: string[];
}

/**
 * Human action request
 */
export interface HumanActionRequest {
  title: string;
  description: string;
  urgency: 'low' | 'medium' | 'high' | 'critical';
  requestedBy: string;
  blockedInitiatives?: string[];
  category?: string;
}

/**
 * GitHub operations interface
 * Abstracted for testability and potential API changes
 */
export interface GitHubOperations {
  /** Check if GitHub API is available */
  isAvailable(): boolean;

  /** Create an issue */
  createIssue(initiative: Initiative): Promise<string | null>;

  /** Add comment to issue */
  addComment(issueNumber: number, comment: string, agentType: string): Promise<boolean>;

  /** Update issue status */
  updateStatus(issueNumber: number, status: IssueStatus, agentType?: string): Promise<boolean>;

  /** Claim issue for agent */
  claimIssue(issueNumber: number, agentType: string): Promise<boolean>;

  /** Complete issue */
  completeIssue(
    issueNumber: number,
    agentType: string,
    setToReview?: boolean,
    comment?: string
  ): Promise<boolean>;

  /** Search for similar issues (deduplication) */
  searchSimilar(title: string): Promise<boolean>;

  /** Fetch open/recent issues for context */
  fetchIssuesSummary(): Promise<GitHubIssuesSummary>;

  /** Create human action request */
  createHumanActionRequest(request: HumanActionRequest): Promise<{
    issueUrl: string | null;
    issueNumber: number | null;
  }>;
}

// =============================================================================
// DEDUPLICATION
// =============================================================================

/**
 * Deduplication strategy interface
 */
export interface DeduplicationStrategy {
  /** Generate hash for an initiative title */
  generateHash(title: string): string;

  /** Check if initiative was already created */
  wasCreated(title: string): Promise<boolean>;

  /** Mark initiative as created */
  markCreated(title: string): Promise<void>;

  /** Calculate similarity between two strings (0-1) */
  calculateSimilarity(a: string, b: string): number;
}

// =============================================================================
// RUNNER
// =============================================================================

/**
 * Initiative runner configuration
 */
export interface RunnerConfig {
  /** Registry instance */
  registry: InitiativeRegistry;

  /** GitHub operations */
  github: GitHubOperations;

  /** Deduplication strategy */
  dedup: DeduplicationStrategy;

  /** Default cooldown in seconds */
  defaultCooldown?: number;

  /** Context cache TTL in seconds */
  contextCacheTTL?: number;
}

/**
 * Initiative Runner Interface
 * Orchestrates the initiative generation and creation flow
 */
export interface InitiativeRunner {
  /**
   * Run initiative phase for an agent
   */
  run<T = unknown>(agentType: AgentType): Promise<InitiativePhaseResult<T>>;

  /**
   * Check if agent can run initiative (not in cooldown)
   */
  canRun(agentType: AgentType): Promise<boolean>;

  /**
   * Build context for initiative generation
   */
  buildContext(agentType: AgentType): Promise<AggregatedContext>;

  /**
   * Build prompt for AI initiative generation
   */
  buildPrompt(agentType: AgentType): Promise<string>;

  /**
   * Create initiative from proposal
   */
  createFromProposal<T = unknown>(
    agentType: AgentType,
    proposal: InitiativeProposal
  ): Promise<InitiativeResult<T>>;

  /**
   * Get initiative statistics
   */
  getStats(): Promise<{
    totalCreated: number;
    agentCooldowns: Record<AgentType, boolean>;
  }>;
}
