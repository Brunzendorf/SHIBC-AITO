/**
 * GitHub Issue Operations
 * TASK-037: Issue CRUD operations for initiatives
 */

import { createLogger } from '../../logger.js';
import type {
  Initiative,
  GitHubIssuesSummary,
  HumanActionRequest,
  IssueStatus,
  AgentFocusConfig,
} from '../types.js';
import { STATUS_LABELS } from '../types.js';
import {
  getOctokit,
  getRepoConfig,
  getHumanUsername,
  searchIssuesBreaker,
  listIssuesBreaker,
  createIssueBreaker,
} from './client.js';
import { refreshBacklogCache } from './cache.js';

const logger = createLogger('initiative:github:issues');

// =============================================================================
// ISSUE CREATION
// =============================================================================

/**
 * Create a GitHub issue for an initiative
 */
export async function createGitHubIssue(
  initiative: Initiative,
  agentFocusConfig?: AgentFocusConfig
): Promise<string | null> {
  const { owner, repo } = getRepoConfig();

  try {
    // Map priority to labels
    const priorityLabel = `priority:${initiative.priority}`;
    const labels = [
      priorityLabel,
      `agent:${initiative.suggestedAssignee}`,
      ...initiative.tags.map((t) => t.toLowerCase()),
    ];

    // Create issue body
    const revenueAngles = agentFocusConfig?.revenueAngles.join(', ') || 'TBD';
    const body = `## Description

${initiative.description}

## Priority

**${initiative.priority.toUpperCase()}** (Revenue Impact: ${initiative.revenueImpact}/10, Effort: ${initiative.effort}/10)

## Revenue Angle

This initiative contributes to revenue by: ${revenueAngles}

## Suggested Assignee

@${initiative.suggestedAssignee}-agent

## Source

Auto-generated by AITO Initiative System from: ${initiative.source}

---
*Created by AITO autonomous initiative system*`;

    // Use circuit breaker for issue creation
    const response = await createIssueBreaker.fire(owner, repo, initiative.title, body, labels);

    if (!response) {
      logger.warn({ title: initiative.title }, 'GitHub issue creation skipped - circuit open');
      return null;
    }

    logger.info({
      issueNumber: response.number,
      title: initiative.title,
    }, 'Created GitHub issue');

    return response.html_url;
  } catch (error) {
    logger.error({ error, initiative: initiative.title }, 'Failed to create GitHub issue');
    return null;
  }
}

/**
 * Create a GitHub issue for human action request (assigned to human)
 */
export async function createHumanActionRequest(
  request: HumanActionRequest
): Promise<{ issueUrl: string | null; issueNumber: number | null }> {
  const { owner, repo } = getRepoConfig();
  const humanUsername = getHumanUsername();

  try {
    const gh = getOctokit();

    const urgencyEmoji = {
      low: 'ðŸ“‹',
      medium: 'âš ï¸',
      high: 'ðŸ”´',
      critical: 'ðŸš¨',
    }[request.urgency];

    const labels = [
      'human-action-required',
      `urgency:${request.urgency}`,
      `from:${request.requestedBy}`,
    ];
    if (request.category) labels.push(request.category);

    const body = `${urgencyEmoji} **Human Action Required**

## Request
${request.description}

## Urgency
**${request.urgency.toUpperCase()}**

## Requested By
${request.requestedBy.toUpperCase()} Agent

${request.blockedInitiatives?.length ? `## Blocked Initiatives
${request.blockedInitiatives.map((i) => `- ${i}`).join('\n')}` : ''}

---
*This issue was automatically created by AITO because an agent needs human input to proceed.*
*Please resolve this and close the issue when done - the agent will be notified.*`;

    const response = await gh.issues.create({
      owner,
      repo,
      title: `${urgencyEmoji} [Human Required] ${request.title}`,
      body,
      labels,
      assignees: [humanUsername],
    });

    logger.info({
      issueNumber: response.data.number,
      title: request.title,
      assignee: humanUsername,
    }, 'Created human action request issue');

    return {
      issueUrl: response.data.html_url,
      issueNumber: response.data.number,
    };
  } catch (error) {
    logger.error({ error, title: request.title }, 'Failed to create human action request');
    return { issueUrl: null, issueNumber: null };
  }
}

// =============================================================================
// ISSUE COMMENTS
// =============================================================================

/**
 * Add a comment to a GitHub issue (for agent progress updates)
 */
export async function addIssueComment(
  issueNumber: number,
  comment: string,
  agentType: string
): Promise<boolean> {
  const { owner, repo } = getRepoConfig();

  try {
    const gh = getOctokit();

    const body = `**[${agentType.toUpperCase()} Agent Update]**

${comment}

---
*Automated update from AITO agent system*`;

    await gh.issues.createComment({
      owner,
      repo,
      issue_number: issueNumber,
      body,
    });

    logger.info({ issueNumber, agentType }, 'Added comment to issue');
    return true;
  } catch (error) {
    logger.error({ error, issueNumber }, 'Failed to add issue comment');
    return false;
  }
}

// =============================================================================
// ISSUE STATUS MANAGEMENT
// =============================================================================

/**
 * Update an issue's status label on GitHub
 */
export async function updateIssueStatus(
  issueNumber: number,
  newStatus: IssueStatus,
  agentType?: string
): Promise<boolean> {
  const { owner, repo } = getRepoConfig();

  try {
    const gh = getOctokit();

    // Get current labels
    const issue = await gh.issues.get({ owner, repo, issue_number: issueNumber });
    const currentLabels = issue.data.labels.map((l) =>
      typeof l === 'string' ? l : l.name || ''
    );

    // Remove old status labels, keep others
    const newLabels = currentLabels.filter((l) => !l.startsWith('status:'));

    // Add new status label
    newLabels.push(STATUS_LABELS[newStatus]);

    // Update labels
    await gh.issues.setLabels({
      owner,
      repo,
      issue_number: issueNumber,
      labels: newLabels,
    });

    logger.info({
      issueNumber,
      newStatus: STATUS_LABELS[newStatus],
      agentType,
    }, 'Updated GitHub issue status');

    // Refresh backlog cache
    await refreshBacklogCache();

    return true;
  } catch (error) {
    logger.error({ error, issueNumber, newStatus }, 'Failed to update issue status');
    return false;
  }
}

/**
 * Claim an issue - set to in-progress and assign to agent
 */
export async function claimIssue(
  issueNumber: number,
  agentType: string
): Promise<boolean> {
  const { owner, repo } = getRepoConfig();

  try {
    const gh = getOctokit();

    // Get current labels
    const issue = await gh.issues.get({ owner, repo, issue_number: issueNumber });
    const currentLabels = issue.data.labels.map((l) =>
      typeof l === 'string' ? l : l.name || ''
    );

    // Check if already in-progress by another agent
    const hasOtherAgent = currentLabels.some(
      (l) => l.startsWith('agent:') && l !== `agent:${agentType}`
    );
    if (hasOtherAgent && currentLabels.includes(STATUS_LABELS.IN_PROGRESS)) {
      logger.warn({ issueNumber, agentType }, 'Issue already claimed by another agent');
      return false;
    }

    // Remove old status labels and agent labels
    const newLabels = currentLabels.filter(
      (l) => !l.startsWith('status:') && !l.startsWith('agent:')
    );

    // Add in-progress status and agent label
    newLabels.push(STATUS_LABELS.IN_PROGRESS);
    newLabels.push(`agent:${agentType}`);

    // Update labels
    await gh.issues.setLabels({
      owner,
      repo,
      issue_number: issueNumber,
      labels: newLabels,
    });

    // Add comment
    await gh.issues.createComment({
      owner,
      repo,
      issue_number: issueNumber,
      body: `ðŸ¤– **${agentType.toUpperCase()} Agent** is now working on this issue.`,
    });

    logger.info({ issueNumber, agentType }, 'Agent claimed issue');

    // Refresh backlog cache
    await refreshBacklogCache();

    return true;
  } catch (error) {
    logger.error({ error, issueNumber, agentType }, 'Failed to claim issue');
    return false;
  }
}

/**
 * Complete an issue - set to done or review
 */
export async function completeIssue(
  issueNumber: number,
  agentType: string,
  setToReview = false,
  completionComment?: string
): Promise<boolean> {
  const { owner, repo } = getRepoConfig();

  try {
    const gh = getOctokit();

    // Update status
    const newStatus: IssueStatus = setToReview ? 'REVIEW' : 'DONE';
    await updateIssueStatus(issueNumber, newStatus, agentType);

    // Add completion comment
    const comment =
      completionComment ||
      (setToReview
        ? `âœ… **${agentType.toUpperCase()} Agent** has completed work and moved this to review.`
        : `âœ… **${agentType.toUpperCase()} Agent** has completed this issue.`);

    await gh.issues.createComment({
      owner,
      repo,
      issue_number: issueNumber,
      body: comment,
    });

    // Close issue if done (not review)
    if (!setToReview) {
      await gh.issues.update({
        owner,
        repo,
        issue_number: issueNumber,
        state: 'closed',
      });
    }

    logger.info({ issueNumber, agentType, setToReview }, 'Agent completed issue');

    return true;
  } catch (error) {
    logger.error({ error, issueNumber, agentType }, 'Failed to complete issue');
    return false;
  }
}

// =============================================================================
// ISSUE FETCHING
// =============================================================================

/**
 * Fetch open GitHub issues for context
 * Uses circuit breaker to prevent cascading failures
 */
export async function fetchGitHubIssues(): Promise<GitHubIssuesSummary> {
  try {
    const { owner, repo } = getRepoConfig();

    // Get open and closed issues using circuit breaker
    const [openIssues, closedIssues] = await Promise.all([
      listIssuesBreaker.fire(owner, repo, 'open', 15),
      listIssuesBreaker.fire(owner, repo, 'closed', 10),
    ]);

    return {
      open: openIssues.map((i) => {
        const labelNames = i.labels.map((l) => (typeof l === 'string' ? l : l.name)).filter(Boolean);
        return `#${i.number}: ${i.title} [${labelNames.join(', ')}]`;
      }),
      recent: closedIssues.map((i) => `#${i.number}: ${i.title} (closed)`),
    };
  } catch (error) {
    logger.debug({ error }, 'Failed to fetch GitHub issues');
    return { open: [], recent: [] };
  }
}

/**
 * Search for similar issues (for deduplication)
 */
export async function searchForSimilarIssue(
  title: string,
  similarityThreshold = 0.8
): Promise<{ found: boolean; issueNumber?: number }> {
  try {
    const { owner, repo } = getRepoConfig();

    // Extract key words from title for search
    const keywords = title
      .toLowerCase()
      .replace(/[^a-z0-9\s]/g, '')
      .split(/\s+/)
      .filter((w) => w.length > 3)
      .slice(0, 5)
      .join(' ');

    if (!keywords) return { found: false };

    // Search using circuit breaker
    const searchResults = await searchIssuesBreaker.fire(keywords, owner, repo, 30);

    // Check for similar titles using fuzzy matching
    const normalizedTitle = title.toLowerCase().replace(/[^a-z0-9]/g, '');
    for (const issue of searchResults) {
      const issueTitle = issue.title.toLowerCase().replace(/[^a-z0-9]/g, '');

      // Check for exact match
      if (issueTitle === normalizedTitle) {
        logger.info({ title, existingIssue: issue.number }, 'Exact duplicate found on GitHub');
        return { found: true, issueNumber: issue.number };
      }

      // Check for high similarity (>threshold overlap)
      const similarity = calculateSimilarity(normalizedTitle, issueTitle);
      if (similarity > similarityThreshold) {
        logger.info({ title, existingIssue: issue.number, similarity }, 'Similar issue found on GitHub');
        return { found: true, issueNumber: issue.number };
      }
    }

    return { found: false };
  } catch (error) {
    // TASK-009: Distinguish error types for proper handling
    const isRateLimit =
      error instanceof Error &&
      (error.message.includes('rate limit') ||
        error.message.includes('403') ||
        error.message.includes('429') ||
        error.message.includes('API rate limit exceeded'));

    if (isRateLimit) {
      logger.warn({ error, title }, 'GitHub rate limited, assuming duplicate to be safe');
      return { found: true }; // Assume duplicate to prevent spam
    }

    logger.warn({ error, title }, 'Failed to check GitHub for duplicates');
    return { found: false };
  }
}

/**
 * Calculate Jaccard similarity between two strings
 */
function calculateSimilarity(a: string, b: string): number {
  const wordsA = new Set(a.match(/[a-z0-9]+/g) || []);
  const wordsB = new Set(b.match(/[a-z0-9]+/g) || []);

  if (wordsA.size === 0 && wordsB.size === 0) return 1;
  if (wordsA.size === 0 || wordsB.size === 0) return 0;

  const intersection = new Set([...wordsA].filter((x) => wordsB.has(x)));
  const union = new Set([...wordsA, ...wordsB]);

  return intersection.size / union.size;
}
